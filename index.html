<!DOCTYPE html>
<html lang="en">
<head>
<link rel="apple-touch-icon" href="./icon-192.png">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="./manifest.json">
<meta name="theme-color" content="#C7F0D8">

<script>
if ("serviceWorker" in navigator) {
  window.addEventListener("load", () => {
    navigator.serviceWorker.register("service-worker.js");
  });
}
</script>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Retro Battle</title>

  <style>
    * { box-sizing: border-box; }

html, body {
  height: 100%;
  margin: 0;
}

body{
  background:#C7F0D8;
  font-family:'Courier New', monospace;

  display:flex;
  justify-content:center;
  align-items:flex-start;               /* ✅ don’t vertically center (prevents weird gaps) */

  padding-top: calc(env(safe-area-inset-top) + 12px);
  padding-bottom: calc(env(safe-area-inset-bottom) + 12px);
  padding-left: env(safe-area-inset-left);
  padding-right: env(safe-area-inset-right);

  overflow-x:hidden;
}

    /* =========================
       WRAP (Overworld + Battle)
    ========================= */
    #screenWrap {
  width: 640px;
  max-width: 95vw;
  max-height: 95vh;          /* ✅ prevents it from exceeding screen height */
}

    /* =========================
       OVERWORLD
    ========================= */
    #overworld {
      width: 640px;
      max-width: 95vw;
      background: #FFF;
      border: 4px solid #000;
      padding: 10px;
      display: none; /* shown by JS */
    }

    #overworldCanvas {
      width: 100%;
      height: auto;
      border: 3px solid #000;
      background: #C7F0D8;
      image-rendering: pixelated;
      display: block;
    }

    /* --- MOBILE CONTROLS --- */
    #owControls{
  display:flex;
  justify-content:space-between;
  align-items:center;
  gap:14px;
  margin-top:12px;
}

#dpad{
  width:156px;
  height:156px;
  display:grid;
  grid-template-columns:52px 52px 52px;
  grid-template-rows:52px 52px 52px;
  gap:6px;
}

/* ✅ Force the D-pad into a real cross */
#btnUp    { grid-column: 2; grid-row: 1; }
#btnLeft  { grid-column: 1; grid-row: 2; }
#btnRight { grid-column: 3; grid-row: 2; }
#btnDown  { grid-column: 2; grid-row: 3; }

/* ✅ iOS button reset */
.owBtn{
  -webkit-appearance: none;
  appearance: none;
  text-decoration: none;
  line-height: 1;
}

.owBtn{
  border:3px solid #000;
  background:#fff;
  color:#000;                /* ✅ fix iOS blue text */
  font-family:inherit;
  font-weight:bold;
  border-radius:10px;        /* ✅ nicer */
  box-shadow:3px 3px 0 #000; /* ✅ retro */
  display:flex;
  align-items:center;
  justify-content:center;
  touch-action:manipulation;
}

.owBtn:active{
  transform:translate(2px,2px);
  box-shadow:1px 1px 0 #000;
}

#owActions{
  display:flex;
  flex-direction:column;
  gap:10px;
}

#owActions .owBtn{
  width:190px;
  height:54px;
  font-size:16px;
}

#owHint{
  margin-top:10px;
  font-size:12px;
  opacity:0.85;
}

    /* =========================
       BATTLE
    ========================= */
    #battle {
      width: 640px;
      max-width: 95vw;
      background: #FFF;
      border: 4px solid #000;
      padding: 16px;
      position: relative;
      overflow: hidden;
      display: none; /* shown by JS */
    }

    /* Crit shake */
    #battle.shake { animation: shake 220ms linear; }
    @keyframes shake {
      0% { transform: translate(0,0); }
      20% { transform: translate(-4px, 2px); }
      40% { transform: translate(4px, -2px); }
      60% { transform: translate(-3px, -2px); }
      80% { transform: translate(3px, 2px); }
      100% { transform: translate(0,0); }
    }

    .row {
      display: flex;
      justify-content: space-between;
      align-items: flex-end;
      gap: 12px;
      position: relative; /* ✅ stacking */
      z-index: 1;         /* ✅ keep UI above base */
    }

    .info {
      border: 3px solid #000;
      padding: 10px;
      width: 280px;
      position: relative; /* ✅ stacking */
      z-index: 1;
    }

    .name {
      display: flex;
      justify-content: space-between;
      font-weight: bold;
      margin-bottom: 6px;
    }

    .hp-wrap {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .hp-label { font-weight: bold; }

    .hp-bar {
      flex: 1;
      height: 12px;
      background: #FF4444;
      border: 2px solid #000;
    }

    .hp-inner {
      width: 100%;
      height: 100%;
      background: #44FF44;
      transition: width 250ms linear;
    }

    /* Sprites */
    .sprite {
      width: 140px;
      height: 140px;
      border: 3px solid #000;
      display: flex;
      align-items: flex-end;
      justify-content: center;
      background: #F7F7F7;
      user-select: none;
      overflow: hidden;
      position: relative; /* ✅ stacking */
      z-index: 1;         /* ✅ keep sprites above base */
    }

    .sprite img {
      width: 100px;
      height: auto;
      image-rendering: pixelated;
    }

    #enemySprite img { transform: scaleX(-1); }

    .flash { animation: flash 120ms linear 2; }
    @keyframes flash {
      0% { filter: brightness(1); }
      50% { filter: brightness(2.5); }
      100% { filter: brightness(1); }
    }

    #textbox {
      margin-top: 14px;
      border: 3px solid #000;
      padding: 12px;
      min-height: 96px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      gap: 10px;
      cursor: pointer;
      position: relative; /* ✅ stacking */
      z-index: 3;         /* ✅ keep textbox above FX */
    }

    #message {
      white-space: pre-wrap;
      line-height: 1.2;
      font-size: 16px;
      min-height: 42px;
    }

    #soundHint{
      font-size: 12px;
      opacity: 0.7;
      margin-top: 6px;
    }

    #menu {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
    }

    button {
      font-family: inherit;
      font-size: 16px;
      padding: 10px;
      border: 3px solid #000;
      background: #FFF;
      cursor: pointer;
    }

    button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .tiny { font-size: 13px; opacity: 0.9; }

    /* FX overlay */
    #effects {
      position: absolute;
      inset: 0;
      pointer-events: none;
      overflow: hidden;
      z-index: 2; /* ✅ FIX: FX now renders ABOVE sprites/info */
    }

    .fx {
      position: absolute;
      transform: translate(-50%, -50%);
      opacity: 0;
    }

    .fx.flame {
      width: 90px; height: 90px;
      border-radius: 50%;
      background: radial-gradient(circle, rgba(255,220,120,1) 0%, rgba(255,120,0,1) 35%, rgba(255,0,0,0.0) 70%);
      animation: pop 260ms ease-out;
    }

    .fx.zap {
      width: 14px; height: 120px;
      background: linear-gradient(to bottom, rgba(255,255,160,1), rgba(80,160,255,1));
      clip-path: polygon(40% 0%, 70% 20%, 55% 20%, 80% 55%, 52% 55%, 70% 100%, 30% 70%, 46% 70%, 20% 40%, 48% 40%);
      animation: zap 260ms ease-out;
    }

    .fx.smoke {
      width: 110px; height: 60px;
      border-radius: 30px;
      background: radial-gradient(circle, rgba(170,255,170,0.95) 0%, rgba(80,180,80,0.55) 55%, rgba(0,0,0,0) 80%);
      animation: drift 380ms ease-out;
    }

    .fx.slash {
      width: 140px; height: 10px;
      background: #000;
      transform: translate(-50%, -50%) rotate(-18deg);
      animation: slash 210ms ease-out;
    }

    .fx.buff {
      width: 120px; height: 120px;
      border-radius: 16px;
      border: 4px solid rgba(0,0,0,1);
      box-shadow: 0 0 0 6px rgba(255,255,255,0.5), 0 0 24px rgba(120,255,120,0.9);
      animation: buff 420ms ease-out;
    }

    @keyframes pop {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.3); }
      30% { opacity: 1; }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.25); }
    }
    @keyframes zap {
      0% { opacity: 0; transform: translate(-50%, -50%) scaleY(0.4); }
      30% { opacity: 1; }
      100% { opacity: 0; transform: translate(-50%, -50%) scaleY(1.05); }
    }
    @keyframes drift {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.85); }
      25% { opacity: 1; }
      100% { opacity: 0; transform: translate(-50%, -65%) scale(1.1); }
    }
    @keyframes slash {
      0% { opacity: 0; transform: translate(-50%, -50%) rotate(-18deg) scaleX(0.3); }
      35% { opacity: 1; }
      100% { opacity: 0; transform: translate(-50%, -50%) rotate(-18deg) scaleX(1.15); }
    }
    @keyframes buff {
      0% { opacity: 0; transform: translate(-50%, -50%) scale(0.6); }
      25% { opacity: 1; }
      100% { opacity: 0; transform: translate(-50%, -50%) scale(1.05); }
    }

    /* --- SLIDE IN ANIMATIONS (SAFE) --- */
    #playerSprite, #enemySprite { opacity: 1; }

    .slide-in-player { animation: slideInPlayer 380ms ease-out forwards; }
    .slide-in-enemy  { animation: slideInEnemy  380ms ease-out forwards; }

    @keyframes slideInPlayer {
      0%   { transform: translateX(-80px); opacity: 0; }
      100% { transform: translateX(0);     opacity: 1; }
    }
    @keyframes slideInEnemy {
      0%   { transform: translateX(80px); opacity: 0; }
      100% { transform: translateX(0);    opacity: 1; }
    }
  </style>
</head>

<body>
  <audio id="bgmBattle" src="battlesong.mp3" loop></audio>
  <div id="screenWrap">

    <!-- OVERWORLD -->
    <div id="overworld">
      <canvas id="overworldCanvas" width="320" height="240"></canvas>

      <!-- ✅ NEW: D-Pad + Actions -->
      <div id="owControls">
        <div id="dpad">
          <button class="owBtn" id="btnUp">&#9650;</button>    <!-- ▲ -->
<button class="owBtn" id="btnLeft">&#9664;</button>  <!-- ◀ -->
<button class="owBtn" id="btnRight">&#9654;</button> <!-- ▶ -->
<button class="owBtn" id="btnDown">&#9660;</button>  <!-- ▼ -->
        </div>

        <div id="owActions">
          <button class="owBtn" id="btnEncounter">ENCOUNTER</button>
          <button class="owBtn" id="btnMute">SOUND: OFF</button>
        </div>
      </div>

      <!-- ✅ FIXED: encoding/bullet -->
      <div id="owHint">Move: D-Pad / Arrow Keys / WASD &#8226; Random encounters while walking</div>
    </div>

    <!-- BATTLE -->
    <div id="battle">
      <div id="effects"></div>

      <!-- Enemy -->
      <div class="row" style="margin-bottom: 26px;">
        <div class="info">
          <div class="name">
            <span id="enemyName">ENEMY</span>
            <span class="tiny">Lv 5</span>
          </div>

          <div class="hp-wrap">
            <span class="hp-label">HP</span>
            <div class="hp-bar">
              <div id="enemyHPBar" class="hp-inner"></div>
            </div>
          </div>

          <div class="tiny">HP: <span id="enemyHPText">?</span>/<span id="enemyHPMaxText">?</span></div>
        </div>

        <div id="enemySprite" class="sprite">
          <img id="enemyImg" src="wes.png" alt="Enemy" />
        </div>
      </div>

      <!-- Player -->
      <div class="row">
        <div id="playerSprite" class="sprite">
          <img id="playerImg" src="bobby.png" alt="Player" />
        </div>

        <div class="info">
          <div class="name">
            <span id="playerName">BOBBY</span>
            <span class="tiny">Lv 7</span>
          </div>

          <div class="hp-wrap">
            <span class="hp-label">HP</span>
            <div class="hp-bar">
              <div id="playerHPBar" class="hp-inner"></div>
            </div>
          </div>

          <div class="tiny">HP: <span id="playerHPText">35</span>/35</div>
        </div>
      </div>

      <!-- Textbox + Menu -->
      <div id="textbox">
        <div>
          <div id="message"></div>
          <div id="soundHint">Tap once to enable sound</div>
        </div>
        <div id="menu"></div>
      </div>
    </div>

  </div>

<script>
  function playBattleMusic() {
  const m = document.getElementById("bgmBattle");
  if (!m) return;
  if (!soundEnabled) return; // respects your mute button
  m.volume = 0.35; // adjust if needed
  m.currentTime = 0;
  m.play().catch(()=>{});
}

function stopBattleMusic() {
  const m = document.getElementById("bgmBattle");
  if (!m) return;
  m.pause();
  m.currentTime = 0;
}
  // =========================
  // SCREEN TOGGLES
  // =========================
  const overworldEl = () => document.getElementById("overworld");
  const battleEl = () => document.getElementById("battle");

  function showOverworld() {
    overworldEl().style.display = "block";
    battleEl().style.display = "none";
  }

  function showBattle() {
    overworldEl().style.display = "none";
    battleEl().style.display = "block";
  }

  // ============================================================
  // PLAYER
  // ============================================================
  const player = {
    name: "BOBBY",
    element: "fire",
    maxHP: 35,
    hp: 35,
    moves: [
      { name: "Scratch", power: 5, accuracy: 95, element: "normal" },
      { name: "Ember",   power: 8, accuracy: 85, element: "fire"   },
      { name: "Bite",    power: 6, accuracy: 90, element: "dark"   },
      { name: "Roar",    power: 0, accuracy: 100, element: "normal" }
    ]
  };

  // ============================================================
  // ENEMY TEMPLATES (WES + STEVEN)
  // ============================================================
  const enemyTemplates = [
    {
      key: "wes",
      name: "WES",
      element: "steel",
      maxHP: 30,
      sprite: "wes.png",
      moves: [
        { name: "ZOOTOPIA ZAP", type: "damage", power: 7, accuracy: 90, element: "electric" },
        { name: "CHOP YOU INTO PIECES", type: "damage", power: 5, accuracy: 95, status: "burn", element: "steel" },
        { name: "THE OPPOSITE OF WHATEVER YOU SAY", type: "damage", power: 10, accuracy: 65, element: "psychic" },
        { name: "MATH HANDS", type: "buff", amount: 2, accuracy: 100, element: "normal" }
      ]
    },
    {
      key: "steven",
      name: "STEVEN",
      element: "electric",
      maxHP: 26,
      sprite: "steven.png",
      moves: [
        { name: "MONSTER BURP", type: "damage", power: 9, accuracy: 75, element: "electric", selfChip: 2, stunChance: 0.20 },
        { name: "VAPE CLOUD", type: "debuff", accuracy: 95, element: "dark", accDown: 15 },
        { name: "NINJA STANCE", type: "buff", accuracy: 100, element: "normal", amount: 3, accBuff: 8 },
        { name: "TRASH DAY WHIRLWIND", type: "damage", power: 12, accuracy: 55, element: "psychic", critBoost: 0.22 }
      ]
    }
  ];

  let enemy = null;

  // ============================================================
  // STATE + STATUS
  // ============================================================
  let state = { phase: "MAIN", canInput: true };

  // Wes mechanics
  let wesPowerBuff = 0;
  let bobbyBurned = false;

  // Steven mechanics
  let playerAccuracyDown = 0;
  let playerStunned = false;

  let enemyAccuracyBuff = 0;
  let enemyPowerBuff = 0;

  // ============================================================
  // UI HELPERS
  // ============================================================
  const el = (id) => document.getElementById(id);

  function setButtons(buttons) {
    const menu = el("menu");
    menu.innerHTML = "";
    for (const b of buttons) {
      const btn = document.createElement("button");
      btn.textContent = b.label;
      btn.disabled = !state.canInput || b.disabled;
      btn.onclick = b.onClick;
      menu.appendChild(btn);
    }
  }

  function updateHP() {
    el("playerHPText").textContent = player.hp;
    el("playerHPBar").style.width = (player.hp / player.maxHP * 100) + "%";

    el("enemyHPText").textContent = enemy.hp;
    el("enemyHPMaxText").textContent = enemy.maxHP;
    el("enemyHPBar").style.width = (enemy.hp / enemy.maxHP * 100) + "%";
  }

  function flashSprite(which) {
    const target = which === "player" ? el("playerSprite") : el("enemySprite");
    target.classList.remove("flash");
    void target.offsetWidth;
    target.classList.add("flash");
  }

  function sleep(ms) { return new Promise(res => setTimeout(res, ms)); }

  // ============================================================
  // CLICK-TO-ADVANCE + PAGING
  // ============================================================
  const LINE_WIDTH = 28;
  const LINES_PER_PAGE = 2;

  function wrapToLines(text, width = LINE_WIDTH) {
    const paragraphs = String(text).split("\n");
    const lines = [];
    for (const p of paragraphs) {
      const words = p.split(" ");
      let line = "";
      for (const w of words) {
        const test = (line ? line + " " : "") + w;
        if (test.length <= width) line = test;
        else {
          if (line) lines.push(line);
          if (w.length > width) {
            lines.push(w.slice(0, width));
            line = w.slice(width);
          } else line = w;
        }
      }
      if (line) lines.push(line);
    }
    return lines;
  }

  function chunkLines(lines, size = LINES_PER_PAGE) {
    const pages = [];
    for (let i = 0; i < lines.length; i += size) pages.push(lines.slice(i, i + size));
    return pages;
  }

  let awaitingAdvance = false;

  function showPrompt(show) {
    const msg = el("message").textContent;
    if (show) {
      if (!msg.endsWith(" >>")) el("message").textContent = msg + " >>";
    } else {
      el("message").textContent = msg.replace(" >>", "");
    }
  }

  function waitForAdvance() {
    awaitingAdvance = true;
    showPrompt(true);

    return new Promise((resolve) => {
      const advance = () => {
        if (!awaitingAdvance) return;
        awaitingAdvance = false;
        showPrompt(false);
        el("textbox").removeEventListener("click", advance);
        document.removeEventListener("keydown", onKey);
        resolve();
      };

      const onKey = (e) => {
        if (e.key === "Enter" || e.key === " " || e.key === "Spacebar") {
          e.preventDefault();
          advance();
        }
      };

      el("textbox").addEventListener("click", advance);
      document.addEventListener("keydown", onKey);
    });
  }

  function setMessageInstant(text) { el("message").textContent = text; }

  async function typeMessage(text, speed = 16) {
    state.canInput = false;
    const lines = wrapToLines(text);
    const pages = chunkLines(lines, LINES_PER_PAGE);

    for (let p = 0; p < pages.length; p++) {
      const pageText = pages[p].join("\n");
      el("message").textContent = "";

      for (let i = 0; i < pageText.length; i++) {
        el("message").textContent += pageText[i];
        await sleep(speed);
      }

      playSfx("ui");
      await waitForAdvance();
    }
  }

  // ============================================================
  // SOUND
  // ============================================================
  let audioCtx = null;
  let soundEnabled = false;

  function ensureAudioUnlocked() {
    try {
      if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      if (audioCtx.state === "suspended") audioCtx.resume();
      soundEnabled = true;
      el("soundHint").textContent = "Sound: ON";
    } catch (e) { soundEnabled = false; }
  }

  (function addAudioUnlockOnce() {
    const unlock = () => {
      ensureAudioUnlocked();
      window.removeEventListener("touchstart", unlock);
      window.removeEventListener("click", unlock);
      window.removeEventListener("keydown", unlock);
    };
    window.addEventListener("touchstart", unlock, { once: true });
    window.addEventListener("click", unlock, { once: true });
    window.addEventListener("keydown", unlock, { once: true });
  })();

  function tone(freq, durMs, vol=0.08, type="square") {
    if (!soundEnabled || !audioCtx) return;
    const t = audioCtx.currentTime;
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type;
    o.frequency.setValueAtTime(freq, t);
    g.gain.setValueAtTime(vol, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + durMs / 1000);
    o.connect(g);
    g.connect(audioCtx.destination);
    o.start(t);
    o.stop(t + durMs / 1000);
  }

  function playSfx(kind) {
    switch(kind) {
      case "ui":       tone(360, 35, 0.03, "square"); break;
      case "hit":      tone(180, 55, 0.06, "square"); break;
      case "fire":     tone(620, 55, 0.045, "sawtooth"); break;
      case "electric": tone(840, 45, 0.045, "square"); break;
      case "dark":     tone(260, 70, 0.045, "triangle"); break;
      case "psychic":  tone(520, 70, 0.045, "triangle"); break;
      case "steel":    tone(300, 60, 0.045, "square"); break;
      case "buff":     tone(740, 90, 0.04, "triangle"); break;
      case "crit":     tone(980, 70, 0.07, "square"); break;
      default:         tone(420, 45, 0.04, "square");
    }
  }

  // ============================================================
  // FX + CRIT SHAKE
  // ============================================================
  function critShake() {
    const b = el("battle");
    b.classList.remove("shake");
    void b.offsetWidth;
    b.classList.add("shake");
    setTimeout(() => b.classList.remove("shake"), 260);
  }

  function spriteCenter(which) {
    const spriteEl = which === "player" ? el("playerSprite") : el("enemySprite");
    const battleRect = el("battle").getBoundingClientRect();
    const r = spriteEl.getBoundingClientRect();
    const x = (r.left - battleRect.left) + r.width / 2;
    const y = (r.top - battleRect.top) + r.height / 2;
    return { x, y };
  }

  function spawnFx(type, x, y) {
    const fx = document.createElement("div");
    fx.className = `fx ${type}`;
    fx.style.left = x + "px";
    fx.style.top = y + "px";
    el("effects").appendChild(fx);
    setTimeout(() => fx.remove(), 650);
  }

  function moveFxFor(element, moveName) {
    const n = String(moveName || "").toUpperCase();
    const elName = String(element || "normal").toLowerCase();

    if (n.includes("ZOOTOPIA") || n.includes("ZAP")) return "zap";
    if (n.includes("EMBER")) return "flame";

    if (n.includes("VAPE")) return "smoke";
    if (n.includes("BURP")) return "smoke";
    if (n.includes("CHOP")) return "slash";
    if (n.includes("STANCE")) return "buff";
    if (n.includes("MATH")) return "buff";

    if (elName === "fire") return "flame";
    if (elName === "electric") return "zap";
    if (elName === "steel") return "slash";
    if (elName === "psychic") return "smoke";
    if (elName === "dark") return "smoke";

    return "slash";
  }

  async function animateMove(attacker, defender, move) {
    const fxType = moveFxFor(move.element || "normal", move.name);
    const de = spriteCenter(defender);
    spawnFx(fxType, de.x, de.y);
    await sleep(80);
  }

  // ============================================================
  // EFFECTIVENESS + ROLLS
  // ============================================================
  const typeChart = {
    fire:     { steel: 2, grass: 2, ice: 2, bug: 2, fire: 0.5, water: 0.5, rock: 0.5, dragon: 0.5 },
    electric: { water: 2, flying: 2, electric: 0.5, grass: 0.5, dragon: 0.5, ground: 0 },
    steel:    { rock: 2, ice: 2, fairy: 2, steel: 0.5, fire: 0.5, water: 0.5, electric: 0.5 },
    psychic:  { fighting: 2, poison: 2, psychic: 0.5, steel: 0.5, dark: 0 },
    dark:     { psychic: 2, ghost: 2, fighting: 0.5, dark: 0.5, fairy: 0.5 },
    normal:   { rock: 0.5, steel: 0.5, ghost: 0 }
  };

  function effectiveness(attackerEl, defenderEl) {
    const row = typeChart[attackerEl];
    if (!row) return 1;
    const mult = row[defenderEl];
    return (mult === undefined) ? 1 : mult;
  }

  function rollHit(baseAccuracy) { return Math.random() * 100 < baseAccuracy; }
  function rollCrit(chance = (1/8)) { return Math.random() < chance; }

  function calcDamage(power) {
    const variance = 0.85 + Math.random() * 0.3;
    return Math.max(1, Math.floor(power * variance));
  }

  // ============================================================
  // MENUS
  // ============================================================
  function showMainMenu() {
    state.phase = "MAIN";
    state.canInput = true;

    setButtons([
      { label: "FIGHT", onClick: () => showFightMenu() },
      { label: "BAG", onClick: async () => {
          state.canInput = false; setButtons([]);
          await typeMessage("You don't have any items...");
          setMessageInstant("What will you do?");
          showMainMenu();
        }
      },
      { label: "SWAP", onClick: async () => {
          state.canInput = false; setButtons([]);
          await typeMessage("No other allies to swap to!");
          setMessageInstant("What will you do?");
          showMainMenu();
        }
      },
      { label: "RUN", onClick: async () => attemptRun() }
    ]);
  }

  function showFightMenu() {
    state.phase = "FIGHT";
    state.canInput = true;

    setButtons([
      ...player.moves.map(m => ({
        label: m.name.toUpperCase(),
        onClick: async () => playerTurn(m)
      })),
      { label: "BACK", onClick: () => {
          setMessageInstant("What will you do?");
          showMainMenu();
        }
      }
    ]);
  }

  // ============================================================
  // SETUP ENEMY (random encounter)
  // ============================================================
  function chooseRandomEnemy() {
    const template = enemyTemplates[Math.floor(Math.random() * enemyTemplates.length)];
    return {
      key: template.key,
      name: template.name,
      element: template.element,
      maxHP: template.maxHP,
      hp: template.maxHP,
      sprite: template.sprite,
      moves: template.moves.map(m => ({ ...m }))
    };
  }

  function applyEnemyToUI() {
    el("enemyName").textContent = enemy.name;
    el("enemyImg").src = enemy.sprite;
    el("enemyHPMaxText").textContent = enemy.maxHP;
  }

  function resetStatusesForNewBattle() {
    wesPowerBuff = 0;
    bobbyBurned = false;

    playerAccuracyDown = 0;
    playerStunned = false;

    enemyAccuracyBuff = 0;
    enemyPowerBuff = 0;

    player.hp = player.maxHP;
  }

  // ============================================================
  // SLIDE IN (BOTH SPRITES)
  // ============================================================
  function playSlideIn() {
    const p = el("playerSprite");
    const e = el("enemySprite");

    p.classList.remove("slide-in-player");
    e.classList.remove("slide-in-enemy");

    void p.offsetWidth;
    void e.offsetWidth;

    p.classList.add("slide-in-player");
    e.classList.add("slide-in-enemy");
  }

  // ============================================================
  // BATTLE FLOW
  // ============================================================
  async function startBattle() {
    playBattleMusic();
    enemy = chooseRandomEnemy();
    resetStatusesForNewBattle();
    applyEnemyToUI();
    updateHP();

    playSlideIn();

    await typeMessage(`A wild ${enemy.name} appeared!`);
    setMessageInstant("What will you do?");
    showMainMenu();
  }

  async function playerTurn(move) {
    if (!state.canInput || state.phase === "END") return;

    if (playerStunned) {
      state.phase = "BUSY";
      state.canInput = false;
      setButtons([]);

      playerStunned = false;
      playSfx("hit");
      await typeMessage(`${player.name} is stunned!\nIt couldn't move!`);

      await enemyTurn();
      return;
    }

    state.phase = "BUSY";
    state.canInput = false;
    setButtons([]);

    await typeMessage(`${player.name} used ${move.name.toUpperCase()}!`);

    const effectiveAcc = Math.max(1, Math.min(100, (move.accuracy ?? 100) - playerAccuracyDown));

    if (move.power === 0) {
      playSfx("buff");
      await animateMove("player", "enemy", move);
      await typeMessage("But nothing happened...");
    } else if (!rollHit(effectiveAcc)) {
      playSfx("hit");
      await typeMessage("It missed!");
    } else {
      let dmg = calcDamage(move.power);
      const mult = effectiveness(move.element || "normal", enemy.element || "normal");
      const crit = rollCrit(1/8);

      if (mult === 0) dmg = 0;
      else {
        dmg = Math.floor(dmg * mult);
        if (crit) dmg = Math.floor(dmg * 1.5);
        dmg = Math.max(1, dmg);
      }

      playSfx(move.element || "hit");
      await animateMove("player", "enemy", move);

      if (crit) { playSfx("crit"); critShake(); }

      if (dmg === 0) {
        await typeMessage("It had no effect...");
      } else {
        enemy.hp = Math.max(0, enemy.hp - dmg);
        flashSprite("enemy");
        updateHP();
        await sleep(90);

        playSfx("hit");
        await typeMessage(`It did ${dmg} damage!`);
        if (crit) await typeMessage("A critical hit!");
        if (mult > 1) await typeMessage("It's super effective!");
        if (mult > 0 && mult < 1) await typeMessage("It's not very effective...");
      }
    }

    if (enemy.hp <= 0) {
      await endBattle(true);
      return;
    }

    await enemyTurn();
  }

  async function enemyTurn() {
    await sleep(140);

    if (bobbyBurned && player.hp > 0) {
      const chip = 2;
      player.hp = Math.max(0, player.hp - chip);
      updateHP();
      playSfx("hit");
      await typeMessage(`${player.name} is burned!\nIt took ${chip} damage!`);

      if (player.hp <= 0) {
        await endBattle(false);
        return;
      }
      await sleep(80);
    }

    const move = enemy.moves[Math.floor(Math.random() * enemy.moves.length)];
    await typeMessage(`${enemy.name} used ${move.name.toUpperCase()}!`);

    const enemyAcc = Math.max(1, Math.min(100, (move.accuracy ?? 100) + enemyAccuracyBuff));

    if (!rollHit(enemyAcc)) {
      playSfx("hit");
      await typeMessage("It missed!");
      setMessageInstant("What will you do?");
      showMainMenu();
      return;
    }

    if (move.type === "buff") {
      if (enemy.key === "wes") {
        wesPowerBuff += (move.amount || 2);
        playSfx("buff");
        await animateMove("enemy", "enemy", move);
        await typeMessage("WES adjusted his safety glasses!");
        await typeMessage("He looks way too confident...");
      }

      if (enemy.key === "steven") {
        enemyPowerBuff += (move.amount || 2);
        enemyAccuracyBuff += (move.accBuff || 6);
        playSfx("buff");
        await animateMove("enemy", "enemy", move);
        await typeMessage("STEVEN hit a ninja stance!");
        await typeMessage("He's doing way too much...");
      }

      setMessageInstant("What will you do?");
      showMainMenu();
      return;
    }

    if (move.type === "debuff") {
      const down = (move.accDown || 10);
      playerAccuracyDown = Math.min(45, playerAccuracyDown + down);
      playSfx("dark");
      await animateMove("enemy", "player", move);
      await typeMessage("A thick vape cloud filled the air!");
      await typeMessage(`${player.name}'s accuracy fell!`);
      setMessageInstant("What will you do?");
      showMainMenu();
      return;
    }

    if (move.type === "damage") {
      let dmg = calcDamage(move.power);

      if (enemy.key === "wes" && wesPowerBuff > 0) {
        dmg += wesPowerBuff;
        wesPowerBuff = 0;
      }

      if (enemy.key === "steven" && enemyPowerBuff > 0) {
        dmg += enemyPowerBuff;
        enemyPowerBuff = 0;
      }

      const mult = effectiveness(move.element || "normal", player.element || "normal");
      const critChance = (move.critBoost != null) ? move.critBoost : (1/8);
      const crit = rollCrit(critChance);

      if (mult === 0) dmg = 0;
      else {
        dmg = Math.floor(dmg * mult);
        if (crit) dmg = Math.floor(dmg * 1.5);
        dmg = Math.max(1, dmg);
      }

      playSfx(move.element || "hit");
      await animateMove("enemy", "player", move);

      if (crit) { playSfx("crit"); critShake(); }

      if (dmg === 0) {
        await typeMessage("It had no effect...");
      } else {
        player.hp = Math.max(0, player.hp - dmg);
        flashSprite("player");
        updateHP();
        await sleep(90);

        playSfx("hit");
        await typeMessage(`${player.name} took ${dmg} damage!`);
        if (crit) await typeMessage("A critical hit!");
        if (mult > 1) await typeMessage("It's super effective!");
        if (mult > 0 && mult < 1) await typeMessage("It's not very effective...");
      }

      if (move.status === "burn" && !bobbyBurned && player.hp > 0) {
        bobbyBurned = true;
        playSfx("fire");
        await typeMessage(`${player.name} was burned!`);
      }

      if (move.selfChip && enemy.hp > 0) {
        enemy.hp = Math.max(1, enemy.hp - move.selfChip);
        updateHP();
        await typeMessage(`${enemy.name} coughed...\nIt took ${move.selfChip} damage!`);
      }

      if (move.stunChance && Math.random() < move.stunChance && player.hp > 0) {
        playerStunned = true;
        await typeMessage(`${player.name} got stunned!`);
      }
    }

    if (player.hp <= 0) {
      await endBattle(false);
      return;
    }

    setMessageInstant("What will you do?");
    showMainMenu();
  }

  async function attemptRun() {
    if (!state.canInput || state.phase === "END") return;

    state.phase = "BUSY";
    state.canInput = false;
    setButtons([]);

    await typeMessage("You tried to run...");

    const success = Math.random() < 0.55;
    if (success) {
      playSfx("ui");
      await typeMessage("Got away safely!");
      await endBattle(null);
    } else {
      playSfx("hit");
      await typeMessage("Couldn't escape!");
      await enemyTurn();
    }
  }

  async function endBattle(playerWon) {
    state.phase = "END";
    state.canInput = false;
    setButtons([]);

    if (playerWon === true) {
      playSfx("ui");
      await typeMessage(`${enemy.name} fainted!\nYou win!`);
      state.canInput = true;

      setButtons([
        { label: "BACK TO OVERWORLD", onClick: () => {
            stopBattleMusic();
            setMessageInstant("");
            showOverworld();
            ow.inBattle = false; // ✅ ensure overworld can move again
          }
        }
      ]);
      return;

    } else if (playerWon === false) {
      playSfx("hit");
      await typeMessage(`${player.name} fainted...\nGame over.`);
    } else if (playerWon === null) {
      playSfx("ui");
      await typeMessage("Got away safely!");
      state.canInput = true;
      setButtons([
        { label: "BACK TO OVERWORLD", onClick: () => {
            stopBattleMusic();
            setMessageInstant("");
            showOverworld();
            ow.inBattle = false;
          }
        }
      ]);
      return;
    }

    state.canInput = true;
    setButtons([{ label: "RESTART", onClick: () => location.reload() }]);
  }

  // =========================
  // OVERWORLD SYSTEM
  // =========================
  const ow = {
    canvas: null,
    ctx: null,
    tile: 16,
    cols: 20, // 320/16
    rows: 15, // 240/16
    player: { x: 10, y: 7 },
    lastMoveAt: 0,
    moveDelay: 90,
    encounterCooldown: 0,
    encounterChance: 0.12, // 12% per step
    inBattle: false,
    floorTile: null
  };

  // =========================
  // OVERWORLD SPRITE SYSTEM (Bobby walk anim) ✅ ADDED
  // =========================
  const owSpriteSrc = {
    down:  ["bobby_down_1.png",  "bobby_down_2.png"],
    up:    ["bobby_up_1.png",    "bobby_up_2.png"],
    left:  ["bobby_left_1.png",  "bobby_left_2.png"],
    right: ["bobby_right_1.png", "bobby_right_2.png"]
  };

  const owSprites = {
    down:  [null, null],
    up:    [null, null],
    left:  [null, null],
    right: [null, null]
  };

  function preloadOverworldSprites(onDone) {
  let total = 0;
  let loaded = 0;

  for (const dir of Object.keys(owSpriteSrc)) {
    owSprites[dir] = owSpriteSrc[dir].map(src => {
      total++;
      const img = new Image();
      img.onload = () => {
        loaded++;
        // ✅ As soon as the very first image loads, redraw so you don't see stick dude
        if (loaded === 1) owDraw();
        // ✅ When all are loaded, call onDone (optional)
        if (loaded === total && typeof onDone === "function") onDone();
      };
      img.onerror = () => {
        loaded++;
        if (loaded === total && typeof onDone === "function") onDone();
      };
      img.src = src;
      return img;
    });
  }
}

  // animation state (defaults)
  ow.player.dir = "down";
  ow.player.frame = 0;
  ow.player.stepToggle = false;

  function owInit() {
    ow.canvas = document.getElementById("overworldCanvas");
    ow.ctx = ow.canvas.getContext("2d");

    // ✅ keep pixel art crisp
    ow.ctx.imageSmoothingEnabled = false;

    // preload floor tile
    ow.floorTile = new Image();
    ow.floorTile.onload = () => owDraw();
    ow.floorTile.onerror = () => console.warn("Failed to load floor_tile.png");
    ow.floorTile.src = "floor_tile.png";

    // ✅ preload Bobby frames once
    preloadOverworldSprites(() => {
  // ✅ ensure the sprite is drawn once everything is ready
  owDraw();
});

    showOverworld();
    owDraw();

    bindOverworldButtons();               // ✅ NEW
    window.addEventListener("keydown", owKeyDown);

    // ✅ Prevent page scrolling (arrows/space) while playing
    window.addEventListener("keydown", (e) => {
      const k = e.key;
      if (["ArrowUp","ArrowDown","ArrowLeft","ArrowRight"," "].includes(k)) {
        e.preventDefault();
      }
    }, { passive: false });
  }

  function owKeyDown(e) {
    if (ow.inBattle) return;

    const key = e.key.toLowerCase();
    const now = Date.now();
    if (now - ow.lastMoveAt < ow.moveDelay) return;

    let dx = 0, dy = 0;
    if (key === "arrowleft" || key === "a") dx = -1;
    if (key === "arrowright" || key === "d") dx = 1;
    if (key === "arrowup" || key === "w") dy = -1;
    if (key === "arrowdown" || key === "s") dy = 1;

    if (dx === 0 && dy === 0) return;

    e.preventDefault();
    ow.lastMoveAt = now;
    owMove(dx, dy);
  }

  function owMove(dx, dy) {
    if (ow.inBattle) return;

    // ✅ Update facing direction
    if (dx === -1) ow.player.dir = "left";
    if (dx ===  1) ow.player.dir = "right";
    if (dy === -1) ow.player.dir = "up";
    if (dy ===  1) ow.player.dir = "down";

    const nx = ow.player.x + dx;
    const ny = ow.player.y + dy;

    if (nx < 0 || ny < 0 || nx >= ow.cols || ny >= ow.rows) return;

    ow.player.x = nx;
    ow.player.y = ny;

    // ✅ Toggle walk frame each step
    ow.player.stepToggle = !ow.player.stepToggle;
    ow.player.frame = ow.player.stepToggle ? 1 : 0;

    ow.encounterCooldown = Math.max(0, ow.encounterCooldown - 1);

    owDraw();

    if (ow.encounterCooldown === 0 && Math.random() < ow.encounterChance) {
      ow.encounterCooldown = 8;
      owStartEncounter();
    }
  }

  function owDraw() {
    const ctx = ow.ctx;
    const t = ow.tile;

    // clear (optional but safe)
    ctx.clearRect(0, 0, ow.canvas.width, ow.canvas.height);

    // floor tiles
    const floorImg = ow.floorTile;
    for (let y = 0; y < ow.rows; y++) {
      for (let x = 0; x < ow.cols; x++) {
        if (floorImg && floorImg.complete && floorImg.naturalWidth > 0) {
          ctx.drawImage(floorImg, x * t, y * t, t, t);
        } else {
          // fallback green tiles while image loads
          const a = (x + y) % 2 === 0;
          ctx.fillStyle = a ? "#8BE28B" : "#79D879";
          ctx.fillRect(x * t, y * t, t, t);
        }
      }
    }

    // player (sprite)
    const px = ow.player.x * t;
    const py = ow.player.y * t;

    const dir = ow.player.dir || "down";
    const frame = ow.player.frame || 0;

    const img = owSprites?.[dir]?.[frame];

    // Draw size/offset tuned for 16px tiles
    if (img && img.complete && img.naturalWidth > 0) {
      ctx.drawImage(img, px - 8, py - 16, 32, 32);
    } else {
      // fallback stick dude if image not loaded yet
      ctx.fillStyle = "#000";
      ctx.fillRect(px + 6, py + 6, 4, 6);
      ctx.fillRect(px + 6, py + 4, 4, 2);
      ctx.fillRect(px + 5, py + 12, 2, 2);
      ctx.fillRect(px + 9, py + 12, 2, 2);
    }
  }

  async function owStartEncounter() {
    if (ow.inBattle) return;
    ow.inBattle = true;

    ensureAudioUnlocked();

    showBattle();

    document.getElementById("message").textContent = "";
    document.getElementById("menu").innerHTML = "";

    await startBattle();
    // NOTE: ow.inBattle flips back to false via "BACK TO OVERWORLD"
  }

  // =========================
  // MOBILE D-PAD + ACTIONS
  // =========================
  function bindOverworldButtons() {
    const up = document.getElementById("btnUp");
    const down = document.getElementById("btnDown");
    const left = document.getElementById("btnLeft");
    const right = document.getElementById("btnRight");

    const encounterBtn = document.getElementById("btnEncounter");
    const muteBtn = document.getElementById("btnMute");

    const press = (dx, dy) => {
      owMove(dx, dy);
    };

    const bindHold = (btn, dx, dy) => {
      let timer = null;

      const start = (e) => {
        e.preventDefault();
        if (ow.inBattle) return;

        press(dx, dy);
        timer = setInterval(() => {
          if (ow.inBattle) return;
          press(dx, dy);
        }, 120);
      };

      const end = (e) => {
        e.preventDefault();
        if (timer) clearInterval(timer);
        timer = null;
      };

      btn.addEventListener("pointerdown", start);
      btn.addEventListener("pointerup", end);
      btn.addEventListener("pointercancel", end);
      btn.addEventListener("pointerleave", end);
    };

    bindHold(up, 0, -1);
    bindHold(down, 0, 1);
    bindHold(left, -1, 0);
    bindHold(right, 1, 0);

    encounterBtn.addEventListener("click", (e) => {
      e.preventDefault();
      owStartEncounter();
    });

    muteBtn.addEventListener("click", (e) => {
      e.preventDefault();
      if (!audioCtx) {
        ensureAudioUnlocked();
      } else {
        soundEnabled = !soundEnabled;
      }
      muteBtn.textContent = soundEnabled ? "SOUND: ON" : "SOUND: OFF";
      if (soundEnabled) playSfx("ui");
    });

    // Make iOS behave nicely with touches
    [up, down, left, right, encounterBtn, muteBtn].forEach(b => {
      b.style.touchAction = "manipulation";
    });
  }

  // Start
  owInit();
</script>
</body>
</html>